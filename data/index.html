<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="main.css">
    <link rel="stylesheet" href="ui.css">

    <title>ESP32_WebOS</title>
</head>

<body>
    <div class="desktop">
        <input id="restart-btn" type="button" title="Restart ESP32"
            onclick="post('restart', function(e){showNewToast(e.xhrOK ? 'Restarting...' : 'Restart failed!')});">

        <div class="invisible desktop-icon-table">
            <div class="desktop-icon-row">
                <div class="desktop-icon" onclick="sendSocket('registerGpioUpdates'); showWindow('gpio-window');">
                    <img src="imgs/esp32.svg">
                    <span class="desktop-icon-title">GPIO Control</span>
                </div>
                <div class="desktop-icon" onclick="showWindow('calculator-window');">
                    <img src="imgs/calculator.svg">
                    <span class="desktop-icon-title">Calculator</span>
                </div>
                <div class="desktop-icon"
                    onclick="sendSocket('registerFsUpdates'); showWindow('file-explorer-window');">
                    <img src="imgs/fs.svg">
                    <span class="desktop-icon-title">File Explorer</span>
                </div>
            </div>

            <div class="desktop-icon-row">
                <div class="desktop-icon">
                    <div id="rssi-container">
                        <div id="rssi-bar"></div>
                    </div>
                    <span class="desktop-icon-title">Network</span>
                </div>
                <div class="desktop-icon">
                    <div id="clock"></div>
                    <span class="desktop-icon-title">Clock</span>
                </div>
                <div class="desktop-icon" onclick="sendSocket('registerBleUpdates'); showWindow('ble-window');">
                    <img src="imgs/ble.svg">
                    <span class="desktop-icon-title">BLE</span>
                </div>
            </div>
        </div>

        <!-- Dialog 'GPIO Control' -->
        <div id="gpio-window" class="window draggable" style="display: none;"
            data-on-close-listener="sendSocket('unregisterGpioUpdates')">
            <div class="window-title-bar drag-bar">
                <span class="window-title">GPIO Control</span>

                <div class="window-ctrls">
                    <input type="button" class="window-ctrl min-ctrl" value="_">
                    <input type="button" class="window-ctrl max-ctrl" value="&#9723;">
                    <input type="button" class="window-ctrl close-ctrl" value="X">
                </div>
            </div>

            <div class="window-body">
                <table id="gpio-table" class="invisible" style="width: 100%;">
                    <thead>
                        <tr>
                            <th>Pin</th>
                            <th>Type</th>
                            <th>Mode</th>
                            <th>Value</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>

        <!-- Dialog 'Calculator' -->
        <div id="calculator-window" class="window draggable" style="display: none;">
            <div class="window-title-bar drag-bar">
                <span class="window-title">Calculator</span>

                <div class="window-ctrls">
                    <input type="button" class="window-ctrl min-ctrl" value="_">
                    <input type="button" class="window-ctrl max-ctrl" value="&#9723;">
                    <input type="button" class="window-ctrl close-ctrl" value="X">
                </div>
            </div>

            <div class="window-body" style="overflow: hidden;">
                <div style="min-width: 255px;">
                    <input id="calc-tb" type="text" style="width: calc(100% - 70px);margin-top: 10px;"><input
                        type="button" onclick="calcTb.value='';" value="CLR">
                </div>
                <table class="invisible calc-pad">
                    <tr>
                        <td><input type="button" onclick="calculatorInput(this.value)" value="("></td>
                        <td><input type="button" onclick="calculatorInput(this.value)" value=")"></td>
                        <td><button onclick="calculatorInput('**')">x<sup>y</sup></button></td>
                        <td><input type="button" onclick="calculatorInput('sqrt(')" value="&#x221A;"></td>
                    </tr>
                    <tr>
                        <td><input type="button" onclick="calculatorInput(this.value)" value="7"></td>
                        <td><input type="button" onclick="calculatorInput(this.value)" value="8"></td>
                        <td><input type="button" onclick="calculatorInput(this.value)" value="9"></td>
                        <td><input type="button" onclick="calculatorInput(this.value)" value="/"></td>
                    </tr>
                    <tr>
                        <td><input type="button" onclick="calculatorInput(this.value)" value="4"></td>
                        <td><input type="button" onclick="calculatorInput(this.value)" value="5"></td>
                        <td><input type="button" onclick="calculatorInput(this.value)" value="6"></td>
                        <td><input type="button" onclick="calculatorInput(this.value)" value="*"></td>
                    </tr>
                    <tr>
                        <td><input type="button" onclick="calculatorInput(this.value)" value="1"></td>
                        <td><input type="button" onclick="calculatorInput(this.value)" value="2"></td>
                        <td><input type="button" onclick="calculatorInput(this.value)" value="3"></td>
                        <td><input type="button" onclick="calculatorInput(this.value)" value="-"></td>
                    </tr>
                    <tr>
                        <td><input type="button" onclick="calculatorInput(this.value)" value="0"></td>
                        <td><input type="button" onclick="calculatorInput(this.value)" value="."></td>
                        <td><input type="button" onclick="calculatorCalc()" value="="></td>
                        <td><input type="button" onclick="calculatorInput(this.value)" value="+"></td>
                    </tr>
                </table>
            </div>
        </div>

        <!-- Dialog 'File Explorer' -->
        <div id="file-explorer-window" class="window draggable" style="display: none;"
            data-on-close-listener="sendSocket('unregisterFsUpdates')">
            <div class="window-title-bar drag-bar">
                <span class="window-title">File Explorer</span>

                <div class="window-ctrls">
                    <input type="button" class="window-ctrl min-ctrl" value="_">
                    <input type="button" class="window-ctrl max-ctrl" value="&#9723;">
                    <input type="button" class="window-ctrl close-ctrl" value="X">
                </div>
            </div>

            <div id="file-explorer-window-body" class="window-body" style="text-align: left;">
                <div id="file-explorer">
                    <div id="nav-view">
                        <input type="button" value="<" title="Go Back" onclick="goBack();">
                        <input type="button" value=">" style="margin-left: 5px;" title="Go Forward" onclick="goFwd();">
                        <input id="path_tb" type="text" value=""
                            style="margin-left: 5px;width: calc(100% - 200px);min-width: 200px;">
                    </div>
                    <div id="view-container">
                        <div id="tree-view"></div>
                        <div id="explorer-view" ondrop="dropHandler(event);" ondragover="dragOverHandler(event);">
                            <!-- Explorer View Content -->
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Dialog 'File Editor' -->
        <div id="file-editor-window" class="window draggable"
            style="min-width: 450px; display: none; height: 500px; width: 500px;">
            <div class="window-title-bar drag-bar">
                <span class="window-title">File Editor -</span><span id="file-editor-filename" class="window-title"
                    style="margin: 5px 0;"></span><span id="file-editor-savestate"></span>

                <div class="window-ctrls">
                    <input type="button" class="window-ctrl min-ctrl" value="_">
                    <input type="button" class="window-ctrl max-ctrl" value="&#9723;">
                    <input type="button" class="window-ctrl close-ctrl" value="X">
                </div>
            </div>

            <div id="file-editor-window-body" class="window-body" style="text-align: left;">
                <div id="file-editor" style="width: 100%; height: 100%;">
                    <div id="nav-view">
                        <input type="button" value="Save" title="Save" onclick="saveFile()">
                        <input type="button" value="Save As" style="margin-left: 5px;" title="Save As"
                            onclick="saveFile(true)">
                    </div>
                    <div id="view-container" style="border: none;">
                        <textarea id="file-content-textarea" oninput="fileEditorSavestate.innerText = '*';"
                            onchange="fileEditorSavestate.innerText = '*';"></textarea>
                    </div>
                </div>
            </div>
        </div>

        <!-- Dialog 'BLE' -->
        <div id="ble-window" class="window draggable" style="display: none;"
            data-on-close-listener="sendSocket('unregisterBleUpdates')">
            <div class="window-title-bar drag-bar">
                <span class="window-title">BLE</span>

                <div class="window-ctrls">
                    <input type="button" class="window-ctrl min-ctrl" value="_">
                    <input type="button" class="window-ctrl max-ctrl" value="&#9723;">
                    <input type="button" class="window-ctrl close-ctrl" value="X">
                </div>
            </div>

            <div class="window-body" style="text-align: left;">
                <input id="ble-scan-btn" type="button" value="Scan for BLE devices" onclick="startBLEScan();"
                    style="margin: 10px;">
                <table id="ble-table" class="invisible" style="border-top: 1px solid;width: 100%;">
                    <tbody>
                        <tr>
                            <td colspan="100%" style="padding: 12px;">Scan not started</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Dialog 'BLE Device Details' -->
        <div id="ble-details-window" class="window draggable" style="display: none;">
            <div class="window-title-bar drag-bar">
                <span class="window-title">BLE Device Details</span>

                <div class="window-ctrls">
                    <input type="button" class="window-ctrl min-ctrl" value="_">
                    <input type="button" class="window-ctrl max-ctrl" value="&#9723;">
                    <input type="button" class="window-ctrl close-ctrl" value="X">
                </div>
            </div>

            <div id="ble-details-window-body" class="window-body" style="text-align: left;">
            </div>
        </div>

    </div>

    <footer>
        <span>
            &copy;2024 <a href="https://github.com/sepp89117" style="color: rgb(68,184,255);">sepp89117</a> ESP32_WebOS
            v0.1
        </span>
    </footer>
</body>


<script>
    const base_url = window.location.origin + "/";
    const sockURL = "ws://" + window.location.host + '/ws';
    var isOnline = false;
    var isBLEConnecting = false;
    var myToast;
    var socket = null;
    var lastResponseDate = 0;
    let currentTime = null;

    function dGet(s) { return document.getElementById(s); }
    function dCre(s) { return document.createElement(s); }
    function dGetByCN(s) { return document.getElementsByClassName(s); }

    const clockElement = dGet('clock');
    const rssiBar = dGet('rssi-bar');
    const gpioTable = dGet('gpio-table');
    const bleTable = dGet('ble-table');
    const bleScanBtn = dGet('ble-scan-btn');
    const calcTb = dGet('calc-tb');
    const bleDetailsWindow = dGet('ble-details-window');
    const bleDetailsWindowBody = dGet('ble-details-window-body');

    const pinModes = {
        1: "INPUT",
        3: "OUTPUT",
        5: "INPUT_PULLUP",
        9: "INPUT_PULLDOWN"
    }

    var lastStatusData = undefined;
    var lastFsData = undefined;
    var lastGpiosData = undefined;
    var lastBleDevsData = undefined;
    var lastBleDevs = [];

    const clockCtxMenu = [
        {
            label: "Update time from NTP",
            onclick: function () {
                post(
                    'update_ntp',
                    function (e) { showNewToast(e.xhrOK ? 'Update...' : 'Update failed!') }
                );
            }
        },
        {
            label: "Set GMT offset",
            onclick: function () {
                var offset = prompt("Enter the desired offset in seconds");
                if (offset !== null) {
                    offset = parseInt(offset);
                    if (!isNaN(offset))
                        if (isValidGmtOffset(offset))
                            post(
                                'setRtcOffset',
                                function (e) { showNewToast(e.xhrOK ? 'Set offset...' : 'Set offset failed!') },
                                "offset=" + encodeURIComponent(offset)
                            );
                        else
                            showNewToast("Offset '" + offset + "' is invalid!");
                }
            }
        }
    ];
    const isValidGmtOffset = offsetSeconds =>
        offsetSeconds >= -43200 && offsetSeconds <= 50400 && offsetSeconds % 900 === 0;


    window.addEventListener("DOMContentLoaded", function () {
        // Start async communication
        if (base_url != "null/") {
            setTimeout(() => {
                initWebSocket();
            }, 1000);
        } else
            alert("Could not get base URL!\nNo communication possible!");

        setTimeout(() => {
            updateStatus();
        }, 1000);

        initWindows();

        initDraggables();

        new PopupMenu(clockElement, ["contextmenu"], clockCtxMenu);
    });

    function initWebSocket() {
        socket = new WebSocket(sockURL);
        socket.binaryType = "arraybuffer";

        socket.onopen = function (event) {
            console.log("Connected to WebSocket");
            lastResponseDate = Date.now();
        };

        socket.onmessage = function (event) {
            var data = event.data;
            lastResponseDate = Date.now();

            try {
                var jRes = JSON.parse(data);

                if (jRes.status != undefined) {
                    lastStatusData = jRes.status;
                    currentTime = parseInt(lastStatusData.ts, 10);
                }

                if (jRes.fs != undefined)
                    lastFsData = jRes.fs;

                if (jRes.gpios != undefined)
                    lastGpiosData = jRes.gpios;

                if (jRes.bleDevs != undefined)
                    lastBleDevsData = jRes.bleDevs;

            }
            catch (e) {
                console.log("Received non JSON data from server: " + data);
            }
        };

        socket.onclose = function (event) {
            console.log("Disconnected from WebSocket! Code: " + event.code);
            socket = null;
            setTimeout(initWebSocket, 1000);
        };

        socket.onerror = function (event) {
            console.log("WebSocket error!");
        };
    }

    function isSocketOnline() {
        return socket !== null && socket !== undefined && socket.readyState === WebSocket.OPEN
    }

    function updateStatus() {
        setTimeout(() => {
            updateStatus();
        }, 1000);

        let wasBLEConnecting = isBLEConnecting;
        isBLEConnecting = lastStatusData != undefined && lastStatusData.bleConnecting;
        var checkBleConnected = false;

        let wasOnline = isOnline;
        isOnline = Date.now() - lastResponseDate < (isBLEConnecting ? 15000 : 5000);

        if (wasOnline && !isOnline)
            showNewToast("Offline!", "red");
        else if (!wasOnline && isOnline)
            showNewToast("Online", "green");

        if (wasBLEConnecting && !isBLEConnecting) {
            checkBleConnected = true;
        } else if (!wasBLEConnecting && isBLEConnecting) {
            showNewToast("Connecting BLE Device...", "yellow");
        }

        if (!isOnline && socket !== null && socket.readyState === WebSocket.OPEN) {
            console.log("Closing socket cause timeout...");
            socket.close();
        }

        if (lastStatusData != undefined) {
            currentTime++;
            clockElement.textContent = formatTime(currentTime);
            updateRssiBar(lastStatusData.wifiRssi);
        }

        if (lastFsData != undefined) {
            sortFileSystemContent(lastFsData);
            const changes = diffFileSystem(lastFsData, file_system_content);
            file_system_content = lastFsData;
            renderTreeView(changes);
        }

        if (lastGpiosData != undefined) {
            updateGPIOTable();
        }

        if (lastBleDevsData != undefined) {
            updateBLETable(checkBleConnected);
        }
    }

    function sortFileSystemContent(content) {
        if (content.isDirectory && content.sub && content.sub.length > 0) {
            content.sub.sort((a, b) => {
                if (a.isDirectory && !b.isDirectory) {
                    return -1;
                }
                if (!a.isDirectory && b.isDirectory) {
                    return 1;
                }
                return a.name.localeCompare(b.name);
            });

            content.sub.forEach(subContent => sortFileSystemContent(subContent));
        }
    }

    function diffFileSystem(newData, oldData) {
        let changes = [];
        const currentPath = [""];
        const currentPath2 = [""];
        const handledPaths = [];
        var maybeRenamed = false;

        function findChanges() {
            let path = currentPath.join('/');
            handledPaths.push(path);

            const _newNode = getContentByPath(path, newData);
            const _oldNode = getContentByPath(path, oldData);

            if (_newNode)
                _newNode.path = path;

            if (!_oldNode) {
                maybeRenamed = true;
                changes.push({ type: "added", path, node: _newNode });
                return;
            }

            if (!_newNode) {
                changes.push({ type: "removed", path, node: _oldNode });
                return;
            }

            if (_newNode.name !== _oldNode.name || _newNode.isDirectory !== _oldNode.isDirectory) {
                changes.push({ type: "updated", path, node: _newNode });
                return;
            }

            if (_newNode.isDirectory) {
                let newSub = _newNode.sub || [];
                let oldSub = _oldNode.sub || [];
                let maxSub = newSub.length >= oldSub.length ? newSub : oldSub; // Meistens newSub, seidenn es wurde ein element gelöscht

                for (let i = 0; i < maxSub.length; i++) {
                    currentPath.push(maxSub[i].name);
                    findChanges();
                    currentPath.pop();
                }
            }
        }

        function checkRenamed() {
            // Wenn umbenannt, gibt es den alten Namen im neuen nicht mehr und den neuen Namen im alten nicht
            let path = currentPath2.join('/');
            const _oldNode = getContentByPath(path, oldData);

            if (handledPaths.indexOf(path) === -1) {
                const _newNode = getContentByPath(path, newData);
                if (!_newNode) {
                    changes.push({ type: "removed", path, node: _oldNode });
                    return;
                }
            }

            if (_oldNode && _oldNode.isDirectory) {
                let oldSub = _oldNode.sub || [];

                for (let i = 0; i < oldSub.length; i++) {
                    currentPath2.push(oldSub[i].name);
                    checkRenamed();
                    currentPath2.pop();
                }
            }
        }

        findChanges();

        if (maybeRenamed) {
            checkRenamed();
        }

        return changes;
    }

    function sendSocket(data) {
        if (isSocketOnline())
            socket.send(data);
    }

    // #region GPIO
    function updateGPIOTable() {
        var gpios = lastGpiosData;

        if (gpioTable.tBodies[0].rows.length === 0) {
            gpios.forEach(gpio => {
                let row = dCre("tr");

                let cell_no = dCre("td");
                let cell_type = dCre("td");
                let cell_mode = dCre("td");
                let cell_value = dCre("td");

                var pinIsFree = gpio.f;
                var pinCanOutput = gpio.o;
                var pinMode = pinModes[gpio.m];

                cell_no.innerText = gpio.n;
                cell_type.innerText = (gpio.t == "D" ? "digital" : "analog");

                if (pinCanOutput && pinIsFree) {
                    cell_mode.innerHTML =
                        "<select onchange=\"setPinMode(" + gpio.n + ", this.value);\">" +
                        "<option value=\"1\"" + (gpio.m == 1 ? " selected" : "") + ">" + pinModes[1] + "</option>" +
                        "<option value=\"3\"" + (gpio.m == 3 ? " selected" : "") + ">" + pinModes[3] + "</option>" +
                        "<option value=\"5\"" + (gpio.m == 5 ? " selected" : "") + ">" + pinModes[5] + "</option>" +
                        "<option value=\"9\"" + (gpio.m == 9 ? " selected" : "") + ">" + pinModes[9] + "</option>" +
                        "</select>";
                } else {
                    cell_mode.innerText = pinMode;
                }

                if (pinIsFree && pinMode == "OUTPUT")
                    cell_value.innerHTML = "<input type=\"number\" min=\"0\" max=\"" + (gpio.t == "D" ? "1" : "4095") + "\" value=\"" + gpio.v + "\" onblur=\"setPinValue(" + gpio.n + ", this.value);\" onchange=\"setPinValue(" + gpio.n + ", this.value);\" onkeydown=\"onGpioInputKeyDown(event, " + gpio.n + ", this.value);\">";
                else
                    cell_value.innerText = gpio.v;

                if (!pinIsFree)
                    row.style.color = "#888";

                row.appendChild(cell_no);
                row.appendChild(cell_type);
                row.appendChild(cell_mode);
                row.appendChild(cell_value);

                gpioTable.tBodies[0].appendChild(row);
            });
        } else {
            var i = 0;
            gpios.forEach(gpio => {
                const row = gpioTable.tBodies[0].rows[i];

                const cell_no = row.cells[0];
                const cell_type = row.cells[1];
                const cell_mode = row.cells[2];
                const cell_value = row.cells[3];

                var pinIsFree = gpio.f;
                var pinCanOutput = gpio.o;
                var pinMode = pinModes[gpio.m];

                cell_no.innerText = gpio.n;
                cell_type.innerText = (gpio.t == "D" ? "digital" : "analog");

                if (pinCanOutput && pinIsFree) {
                    const select = cell_mode.querySelector("select");
                    if (select.value != gpio.m)
                        select.value = gpio.m;
                } else {
                    cell_mode.innerText = pinMode;
                }

                if (pinIsFree && pinMode == "OUTPUT") {
                    const input = cell_value.querySelector("input");
                    if (input === null) {
                        cell_value.innerHTML = "<input type=\"number\" min=\"0\" max=\"" + (gpio.t == "D" ? "1" : "4095") + "\" value=\"" + gpio.v + "\" onblur=\"setPinValue(" + gpio.n + ", this.value);\" onchange=\"setPinValue(" + gpio.n + ", this.value);\" onkeydown=\"onGpioInputKeyDown(event, " + gpio.n + ", this.value);\">";
                    }
                    else if (document.activeElement != input)
                        input.value = gpio.v;
                } else
                    cell_value.innerText = gpio.v;

                if (!pinIsFree)
                    row.style.color = "#888";

                i++;
            });
        }
    }

    function setPinMode(n, m) {
        const gpio = getPin(n);

        if (gpio === null || pinModes[m] === undefined)
            return;

        post("setPinMode",
            function (ev) {
                if (ev.xhrOK)
                    showNewToast(ev.response, "green");
                else
                    showNewToast(ev.response, "red");
            },
            "pin=" + n + "&mode=" + m
        );

        gpio.m = m;
    }

    function setPinValue(n, v) {
        var val = parseInt(v);
        var gpio = getPin(n);
        if (gpio === null)
            return;
        val = Math.min((gpio.t == "D" ? 1 : 4095), Math.max(0, val));

        if (gpio.v != v) {
            post("setPinValue",
                function (ev) {
                    if (ev.xhrOK)
                        showNewToast(ev.response, "green");
                    else
                        showNewToast(ev.response, "red");
                },
                "pin=" + n + "&value=" + v
            );

            gpio.v = v;
        }
    }

    function onGpioInputKeyDown(e, n, v) {
        if (e.keyCode === 13)
            setPinValue(n, v);
    }
    // #endregion GPIO

    // #region BLE
    function startBLEScan() {
        post('scanBLE', function (event) {
            if (event.xhrOK) {
                showNewToast('BLE scan started', 'green');
                bleTable.tBodies[0].innerHTML = '<tr><td colspan="100%" style="padding: 12px;">Scan started...</td></tr>';
                bleScanBtn.disabled = true;
            } else {
                showNewToast('Start BLE scan failed!', 'red');
                bleTable.tBodies[0].innerHTML = '<tr><td colspan="100%" style="padding: 12px;">Start scan failed!</td></tr>';
                bleScanBtn.disabled = false;
            }
        });
    }

    function updateBLETable(checkBleConnected) {
        var bleDevs = lastBleDevsData;
        var onIsConnected = false;
        if (!bleDevArrayEquals(lastBleDevs, bleDevs) && !lastStatusData.bleScanActive) {
            lastBleDevs = bleDevs;
            if (bleDevs.length > 0) {
                bleTable.tBodies[0].innerHTML = "";
                for (var i = 0; i < bleDevs.length; i++) {
                    const ble = bleDevs[i];
                    if (ble.con)
                        onIsConnected = true;
                    let btn_val = !ble.con ? "Connect" : "Disconnect";
                    let btn_fun = !ble.con ? "connectBLEDev" : "disconnectBLEDev";
                    let dev_name = ble.name == "" ? "Unnamed" : ble.name;
                    let adv_int = ble.advi; // The advertisement interval in 0.625ms units.
                    let row = dCre("tr");
                    if (adv_int > 0)
                        row.title = "Advertisement interval in 0.625ms units = " + adv_int;
                    row.innerHTML =
                        `<td style="text-align: center;">
                            <div style="display:block;font-weight: bold;margin-bottom: 3px;">${dev_name}</div>
                            <div style="display:block;">${ble.addr.toUpperCase()}</div>
                        </td>
                        <td style="text-align: center;">
                            <div style="display:block;margin-bottom: 3px;">RSSI</div>
                            <div style="display:block;">${ble.rssi} dBm</div>
                        </td>
                        <td style="vertical-align: top;padding: 12px;">
                            <input type="button" value="${btn_val}" onclick="${btn_fun}(${ble.i});">
                        </td>`;

                    bleTable.tBodies[0].appendChild(row);

                    if (ble.srv.length > 0) {
                        updateBleDetailsWin(ble);
                        if (bleDetailsWindow.style.display != "block")
                            showWindow('ble-details-window');
                    }
                }
            } else {
                bleTable.tBodies[0].innerHTML = '<tr><td colspan="100%" style="padding: 12px;">No devices found.</td></tr>';
            }
            bleScanBtn.disabled = false;
        } else if (lastStatusData.bleScanActive) {
            bleTable.tBodies[0].innerHTML = '<tr><td colspan="100%" style="padding: 12px;">Scan active...</td></tr>';
            bleScanBtn.disabled = true;
        }

        if (checkBleConnected) {
            if (onIsConnected)
                showNewToast("BLE device connected.", "green");
            else
                showNewToast("Connecting BLE device failed!", "red");
        }
    }

    function updateBleDetailsWin(bleDev) {
        bleDetailsWindowBody.innerHTML = "";
        const nameP = dCre("p");
        nameP.innerHTML = "<b>Device Name: " + bleDev.name + "</b>";
        bleDetailsWindowBody.appendChild(nameP);

        const serviceList = dCre("ul");
        serviceList.classList.add("ble-service-list");
        bleDetailsWindowBody.appendChild(serviceList);
        const servicesLi = dCre("li");
        servicesLi.innerHTML = "<b>BLE Services</b>";
        serviceList.appendChild(servicesLi);
        const servicesUl = dCre("ul");
        servicesLi.appendChild(servicesUl);
        for (let i = 0; i < bleDev.srv.length; i++) {
            const service = bleDev.srv[i];
            const serviceLi = dCre("li");
            serviceLi.innerText = service.id + " (" + service.name + ")";
            servicesUl.appendChild(serviceLi);

            const serviceUl = dCre("ul");
            serviceLi.appendChild(serviceUl);
            const chrsLi = dCre("li");
            chrsLi.innerText = "Characteristics";
            serviceUl.appendChild(chrsLi);

            const chrsUl = dCre("ul");
            chrsLi.appendChild(chrsUl);

            for (let i2 = 0; i2 < service.chrs.length; i2++) {
                const chr = service.chrs[i2];
                const chrLi = dCre("li");
                chrsUl.appendChild(chrLi);
                chrLi.innerText = chr.id + " (" + chr.name + ") [ " + chrProToStr(chr.prop) + " ]";
            }
        }
    }

    function chrProToStr(prop) {
        var result = [];

        if ((prop & 0x01) != 0)
            result.push("BROADCAST");
        if ((prop & 0x20) != 0)
            result.push("INDICATE");
        if ((prop & 0x10) != 0)
            result.push("NOTIFY");
        if ((prop & 0x02) != 0)
            result.push("READ");
        if ((prop & 0x08) != 0)
            result.push("WRITE");
        if ((prop & 0x04) != 0)
            result.push("WRITE_NO_RSP");

        return result.join(" | ")
    }

    function connectBLEDev(index) {
        post("conBLE",
            function (ev) {
                if (ev.xhrOK) {
                    //showNewToast(ev.response, "green");
                    if (lastStatusData != undefined)
                        lastStatusData.bleConnecting = true;
                } else
                    showNewToast(ev.response, "red");
            },
            "dev=" + encodeURIComponent(index)
        );
    }

    function disconnectBLEDev(index) {
        post("disconBLE",
            function (ev) {
                if (ev.xhrOK)
                    showNewToast(ev.response, "green");
                else
                    showNewToast(ev.response, "red");
            },
            "dev=" + encodeURIComponent(index)
        );
    }
    // #endregion BLE

    // #region Calculator
    function calculatorInput(val) {
        let begin = calcTb.value.substring(0, calcTb.selectionStart);
        let end = calcTb.value.substring(calcTb.selectionEnd);

        calcTb.value = begin + val + end;

        calcTb.selectionStart = begin.length + val.length;
        calcTb.selectionEnd = calcTb.selectionStart;
    }

    const sqrt = Math.sqrt;
    function calculatorCalc() {
        let expression = calcTb.value;
        if (!isValidMathExpression(expression)) {
            alert("Invalid expression!");
            return;
        }
        try {
            let result = eval(expression);
            calcTb.value = result;

            calcTb.selectionStart = calcTb.value.length;
            calcTb.selectionEnd = calcTb.value.length;
        }
        catch (e) {
            alert("Invalid expression!");
        }
    }

    function isValidMathExpression(str) {
        const regex = /^((?:abs|acos|acosh|asin|asinh|atan|atan2|atanh|cbrt|ceil|clz32|cos|cosh|exp|expm1|floor|fround|hypot|imul|log|log1p|log2|log10|max|min|pow|random|round|sign|sin|sinh|sqrt|tan|tanh|trunc)\(|\d+(?:\.\d+)?|\,|\+|\-|\*|\/|\^|\*\*|\(|\)|\s)+$/;
        return regex.test(str.trim());
    }
    // #endregion

    // #region Helpers
    function getPin(pinNo) {
        if (lastGpiosData === undefined)
            return null;

        return lastGpiosData.find(gpio => gpio.n === pinNo) || null;
    }

    function formatTime(ts) {
        const date = new Date(ts * 1000);

        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        const seconds = String(date.getSeconds()).padStart(2, '0');


        const day = String(date.getDate()).padStart(2, '0');
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const year = String(date.getFullYear()).padStart(4, '0');
        return `${hours}:${minutes}:${seconds}\n${year}-${month}-${day}`;
    }

    function updateRssiBar(rssi) {
        // RSSI-Werte in Prozent umwandeln (anpassen je nach erwarteten RSSI-Bereich)
        const minRssi = -100; // Schwächster RSSI-Wert
        const maxRssi = -30;  // Stärkster RSSI-Wert
        const percentage = ((rssi - minRssi) / (maxRssi - minRssi));

        // Prozentwert im Bereich von 0 bis 100 beschränken
        const clampedPercentage = Math.max(0, Math.min(1, percentage));

        if (clampedPercentage <= 0.1 || !isOnline) // 10%
            rssiBar.style.backgroundColor = "#f00";
        else if (clampedPercentage <= 0.2) // 20%
            rssiBar.style.backgroundColor = "#f60";
        else if (clampedPercentage <= 0.3) // 30%
            rssiBar.style.backgroundColor = "#ff0";
        else
            rssiBar.style.backgroundColor = "#0f0";

        // Breite des Balkens aktualisieren
        rssiBar.style.marginTop = (isOnline ? (1 - clampedPercentage) * rssiBar.clientHeight : 0) + 'px';
    }

    function post(query, callback = null, params = "") {
        var xhr = new XMLHttpRequest();
        var url = base_url + query;
        xhr.open("POST", url, true);
        xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
        xhr.onreadystatechange = function () {
            if (xhr.readyState === 4) {
                if (callback != null) {
                    callback({
                        url: url,
                        query: query,
                        xhrOK: xhr.status === 200,
                        response: xhr.responseText
                    });
                }
            }
        };
        xhr.send(params);
    }

    function loadFile(path, callback) {
        var xhr = new XMLHttpRequest();
        var url = base_url + path.substring(1);
        xhr.onreadystatechange = function () {
            if (xhr.readyState === 4 && xhr.status === 200) {
                hideToast();
                callback(xhr.responseText);
                fileEditorSavestate.innerText = '';
            } else if (xhr.readyState === 4) {
                console.error('Error while loading file:', xhr.status, xhr.statusText);
                showNewToast('Error while loading file!', "red");
            }
        };
        xhr.open("GET", url, true);
        xhr.send();
        showNewToast("Loading file '" + path + "'...", "yellow");
    }

    function saveFile(saveAs = false) {
        var filename = saveAs ? prompt('Enter filename', fileEditorFilename.innerText) : fileEditorFilename.innerText;
        if (filename === null)
            return; // User canceled prompt
        if (filename.substring(0, 1) != "/")
            filename = "/" + filename;
        if (filename.length <= 0) {
            alert('Filename can\'t by empty!');
            return;
        }

        if (saveAs || confirm('Overwrite existing file?')) {
            var blob = new Blob([fileContentTextarea.value], { type: 'text/plain' });
            if (blob.size <= 0) {
                showNewToast('Empty files cannot be uploaded!', 'red');
                return;
            }
            var formData = new FormData();
            formData.append('file', blob, filename);

            var xhr = new XMLHttpRequest();
            xhr.open('POST', '/upload', true);
            xhr.onload = function () {
                if (xhr.status === 200) {
                    showNewToast('File uploaded successfully', 'green');
                    fileEditorSavestate.innerText = '';
                    if (saveAs)
                        fileEditorFilename.innerText = filename;
                } else {
                    showNewToast('Error uploading file', 'red');
                }
            };
            xhr.send(formData);
            showNewToast("Saving file '" + filename + "'...", "green");
        }
    }

    function uploadFile(file, path) {
        var blob = new Blob([file], { type: 'text/plain' });
        if (blob.size <= 0) {
            showNewToast('Empty files cannot be uploaded!', 'red');
            return;
        }
        var formData = new FormData();
        formData.append('file', blob, path);

        var xhr = new XMLHttpRequest();
        xhr.open('POST', '/upload', true);
        xhr.onload = function () {
            if (xhr.status === 200) {
                showNewToast('File uploaded successfully', 'green');
            } else {
                showNewToast('Error uploading file', 'red');
            }
        };
        xhr.send(formData);
        showNewToast("Uploading file '" + path + "'...", "yellow");
    }

    function showNewToast(messageHTML, borderColor = 'white') {
        if (myToast != undefined)
            myToast.hide();
        myToast = new Toast(messageHTML);
        myToast.setStyle({ 'border': '2px solid ' + borderColor });
        myToast.show();
    }

    function hideToast() {
        if (myToast != undefined)
            myToast.hide();
    }

    function bleDevArrayEquals(arr1, arr2) {
        const arrLen = arr1.length;

        if (arrLen != arr2.length)
            return false;

        for (var i = 0; i < arrLen; i++) {
            var dev1 = arr1[i];
            var dev2 = arr2[i];
            if (!bleDevEquals(dev1, dev2))
                return false;
        }
        return true;
    }

    const bleDevEquals = (dev1, dev2) =>
        dev1.addr === dev2.addr &&
        dev1.con === dev2.con &&
        dev1.name === dev2.name &&
        dev1.rssi === dev2.rssi;

    // #endregion Helpers
</script>

<!-- Windows -->
<script>
    const maxWH = "calc(100% - 8px)";
    var currentDragElement = null;
    var winDefaultX = 20; // x and y cords in px 
    var winDefaultY = 20; // x and y cords in px 

    function initWindows() {
        const desktop = document.body.querySelector('div[class="desktop"]');
        desktop.addEventListener("drop", function (ev) {
            ev.preventDefault();
            ev.stopPropagation();
        });
        desktop.addEventListener("dragover", function (ev) {
            ev.preventDefault();
        });

        const windows = dGetByCN("window");
        for (var i = 0; i < windows.length; i++) {
            const _win = windows[i];
            _win.dataset.defaultDisplay = _win.style.display;


            _win.addEventListener("click", function (ev) {
                bringtToFront(this);
            });

            const min_ctrl = _win.querySelector('.min-ctrl');
            const max_ctrl = _win.querySelector('.max-ctrl');
            const close_ctrl = _win.querySelector('.close-ctrl');

            if (min_ctrl != null) {
                min_ctrl.addEventListener("click", function (ev) {
                    var miniWidth = _win.style.minWidth ? _win.style.minWidth : "240px";
                    if (_win.style.width == miniWidth && _win.style.height == "26px") {
                        _win.style.width = _win.dataset.lastWidth;
                        _win.style.height = _win.dataset.lastHeight;
                    } else {
                        _win.dataset.lastWidth = _win.style.width;
                        _win.dataset.lastHeight = _win.style.height;
                        _win.style.width = miniWidth;
                        _win.style.height = "26px";
                    }
                });
            }

            if (max_ctrl != null) {
                max_ctrl.addEventListener("click", function (ev) {
                    if (_win.style.width == maxWH && _win.style.height == maxWH) {
                        _win.style.top = _win.dataset.lastTop;
                        _win.style.left = _win.dataset.lastLeft;
                        _win.style.width = _win.dataset.lastWidth;
                        _win.style.height = _win.dataset.lastHeight;
                    } else {
                        _win.dataset.lastTop = _win.style.top;
                        _win.dataset.lastLeft = _win.style.left;
                        _win.dataset.lastWidth = _win.style.width;
                        _win.dataset.lastHeight = _win.style.height;
                        _win.style.top = "0";
                        _win.style.left = "0";
                        _win.style.width = maxWH;
                        _win.style.height = maxWH;
                    }
                });
            }

            if (close_ctrl != null) {
                close_ctrl.addEventListener("click", function (ev) {
                    _win.style.display = "none";
                    if (_win.dataset.onCloseListener !== undefined) {
                        eval(_win.dataset.onCloseListener);
                    }
                });
            }
        }
    }

    function initDraggables() {
        const draggables = dGetByCN("draggable");

        for (var i = 0; i < draggables.length; i++) {
            const draggable = draggables[i];
            const dragBar = draggable.querySelector('.drag-bar');

            dragBar.addEventListener("mousedown", function (ev) {
                if (ev.target.classList.contains("window-ctrl"))
                    return;
                currentDragElement = draggable;
                currentDragElement.mouseDownX = ev.layerX;
                currentDragElement.mouseDownY = ev.layerY;

                if (draggable.classList.contains("window"))
                    bringtToFront(draggable);
            });
        }

        window.addEventListener("mouseup", function () {
            currentDragElement = null;
        });

        window.addEventListener("mousemove", function (ev) {
            if (currentDragElement === null) return;

            currentDragElement.style.left = (ev.pageX - currentDragElement.mouseDownX) + "px";
            currentDragElement.style.top = (ev.pageY - currentDragElement.mouseDownY) + "px";
        });
    }

    function showWindow(id) {
        const win = dGet(id);

        if (win != null) {
            if (win.style.display != "block") {
                let leftToBottom = window.innerHeight - winDefaultY - 8 - win.clientHeight;
                winDefaultY = leftToBottom < 0 ? (winDefaultY + leftToBottom >= 0 ? winDefaultY + leftToBottom : 0) : winDefaultY;

                win.style.display = "block";
                win.style.top = (win.clientHeight >= window.innerHeight - winDefaultY - 8 ? 0 : winDefaultY) + "px";
                win.style.left = winDefaultX + "px";
                win.style.width = win.clientWidth + "px";
                win.style.height = win.clientHeight + "px";

                if (winDefaultY >= window.innerHeight / 2)
                    winDefaultY = 20;
                else
                    winDefaultY += 40;

                winDefaultX += 40;

                if (winDefaultX >= window.innerWidth / 2)
                    winDefaultX = 20;
            } else {
                let currentTop = parseInt(win.style.top.substring(0, win.style.top.indexOf("px")));
                let currentLeft = parseInt(win.style.left.substring(0, win.style.left.indexOf("px")));
                if (currentLeft < 0)
                    win.style.left = "0px";
                if (currentTop < 0)
                    win.style.top = "0px";
            }

            bringtToFront(win);
        }
    }

    function bringtToFront(el) {
        const windows = document.querySelectorAll('.window');
        let maxZIndex = 100; // default z-index by css
        windows.forEach(win => {
            if (win === el)
                return;
            let win_title = win.querySelector('.window-title');
            if (win_title != null)
                win_title.classList.add("disabled");
            const zIndex = parseInt(window.getComputedStyle(win).zIndex, 10);
            if (!isNaN(zIndex))
                maxZIndex = Math.max(maxZIndex, zIndex);
        });

        el.style.zIndex = maxZIndex + 1;
        let el_title = el.querySelector('.window-title');
        if (el_title != null)
            el_title.classList.remove("disabled");
    }
</script>

<!-- Toast -->
<script>
    /**
     * @class Toast
     * @classdesc Represents a toast notification that can be displayed on a webpage.
     */
    class Toast {
        /**
         * @constructor
         * @param {string} message - The content of the toast message as HTML.
         * @param {number} [duration=0] - The duration (in milliseconds) for which the toast should be visible.
         */
        constructor(message, duration = 0) {
            // Set parameters
            this.message = message;
            this.duration = duration;

            // Set some options
            this.additionalTimeout = 1000; // The time it takes the reader to notice the notification in ms
            this.readingTimePerWord = 433; // The time the reader needs per word in ms

            // Create toast element
            this.toastElement = dCre('div');

            // Toast styling
            this.opacity = '0.7';
            this.styleCss = {
                'width': 'fit-content',
                'max-width': '50%',
                'background-color': '#000',
                'color': '#fff',
                'text-align': 'center',
                'border-radius': '12pt',
                'padding': '12pt 20pt',
                'position': 'fixed',
                'z-index': '11000',
                'left': '50%',
                'transform': 'translate(-50%, 0%)',
                'bottom': '30px',
                'font-family': 'Verdana, sans-serif',
                'font-size': '12pt',
                'transition': 'opacity 0.5s linear',
                'user-select': 'none',
                'cursor': 'default',
                'opacity': '0'
            };
            this.setStyle();

            this.isMouseDown = false;

            document.body.appendChild(this.toastElement);
        }


        /**
         * @method setStyle
         * @description Sets custom styles for the toast element.
         * If no style is specified, the current content of styleCss is written.
         * @param {Object} [style=null] - An object containing CSS style properties and values. Example: {'background-color': '#F00'}
         */
        setStyle(style = null) {
            if (style != null) {
                // Replace or add new styles to this.styleCss
                Object.entries(style).forEach(([key, value]) => {
                    this.styleCss[key] = value;
                });
            }

            this.toastElement.style.cssText = Object.entries(this.styleCss)
                .map(([key, value]) => `${key}:${value}`)
                .join(';');
        }

        /**
         * @method show
         * @description Displays the toast notification with a fade-in effect.
         * If no duration is specified, it calculates an appropriate timeout based on the message length.
         */
        show() {
            var timeout = this.duration;
            if (timeout <= 0) {
                // Calculate timeout
                const wordCount = this.message.split(' ').length;
                timeout += wordCount * this.readingTimePerWord;
                timeout += this.additionalTimeout;
            }

            this.toastElement.innerHTML = this.message;
            this.setStyle({ 'opacity': this.opacity });

            // Schedule automatic hide after the specified timeout
            this.hideTimeout = setTimeout(() => {
                this.hide();
            }, timeout);

            // Clear hide timeout on mousedown
            this.toastElement.addEventListener('mousedown', () => {
                this.isMouseDown = true;
                clearTimeout(this.hideTimeout);
            });

            // Trigger hide on mouseup
            this.toastElement.addEventListener('mouseup', () => {
                this.hide();
            });

            // Trigger hide on mouseup
            this.toastElement.addEventListener('mouseleave', () => {
                if (this.isMouseDown)
                    this.hide();
            });
        }

        /**
         * @method hide
         * @description Hides the toast notification with a fade-out effect and removes it from the document body.
         */
        hide() {
            // Fade out toast element
            this.setStyle({ 'opacity': '0' });

            this.isMouseDown = false;

            // Remove toast element from document body after 2 seconds
            setTimeout(() => {
                try {
                    document.body.removeChild(this.toastElement);
                }
                catch (ignored) {
                }
            }, 2000);
        }
    }
</script>

<!-- File Explorer -->
<script>
    var back_stack = [];
    var fwd_stack = [];

    const arrow_right_svg_symbol = '<path d="M4.7 10c-.2 0-.4-.1-.5-.2-.3-.3-.3-.8 0-1.1L6.9 6 4.2 3.3c-.3-.3-.3-.8 0-1.1.3-.3.8-.3 1.1 0l3.3 3.2c.3.3.3.8 0 1.1L5.3 9.7c-.2.2-.4.3-.6.3Z"></path>';
    const arrow_down_svg_symbol = '<path d="M6 8.825c-.2 0-.4-.1-.5-.2l-3.3-3.3c-.3-.3-.3-.8 0-1.1.3-.3.8-.3 1.1 0l2.7 2.7 2.7-2.7c.3-.3.8-.3 1.1 0 .3.3.3.8 0 1.1l-3.2 3.2c-.2.2-.4.3-.6.3Z"></path>';
    const folder_closed_svg_symbol = '<path d="M1.75 1A1.75 1.75 0 0 0 0 2.75v10.5C0 14.216.784 15 1.75 15h12.5A1.75 1.75 0 0 0 16 13.25v-8.5A1.75 1.75 0 0 0 14.25 3H7.5a.25.25 0 0 1-.2-.1l-.9-1.2C6.07 1.26 5.55 1 5 1H1.75Z"></path>';
    const folder_open_svg_symbol = '<path d="M 0,4.5 H 14 V 4 C 14,3.4477153 13.552285,3 13,3 H 7.75 C 7.6713107,3 7.5972136,2.9629515 7.55,2.9 L 6.65,1.7 C 6.32,1.26 5.8,1 5.25,1 H 1.75 C 1.2859598,1.0002317 0.84101009,1.1847582 0.513,1.513 0.184,1.84 0,2.286 0,2.75 m 0,10.5 C 0,14.216498 0.78350169,15 1.75,15 h 11.5 C 14.216498,15 15,14.216498 15,13.25 L 15.722,7.117 C 15.792084,6.5221087 15.327005,5.99948 14.728,6 H 1.71875 C 1.078125,6.015625 0.66797158,6.46075 0.62109658,7.117 Z"></path>';
    const file_svg_symbol = '<path d="M2 1.75C2 .784 2.784 0 3.75 0h6.586c.464 0 .909.184 1.237.513l2.914 2.914c.329.328.513.773.513 1.237v9.586A1.75 1.75 0 0 1 13.25 16h-9.5A1.75 1.75 0 0 1 2 14.25Zm1.75-.25a.25.25 0 0 0-.25.25v12.5c0 .138.112.25.25.25h9.5a.25.25 0 0 0 .25-.25V6h-2.75A1.75 1.75 0 0 1 9 4.25V1.5Zm6.75.062V4.25c0 .138.112.25.25.25h2.688l-.011-.013-2.914-2.914-.013-.011Z"></path>';

    const path_tb = dGet("path_tb");
    const fileContentTextarea = dGet('file-content-textarea');
    const fileEditorFilename = dGet('file-editor-filename');
    const fileEditorSavestate = dGet('file-editor-savestate');
    const explorerView = dGet('explorer-view');
    const treeView = dGet('tree-view');

    const explorerCtxMenu = [
        {
            label: "Create File",
            onclick: function () {
                mkFile();
            }
        },
        {
            label: "Create Directory",
            onclick: function () {
                mkDir();
            }
        }
    ];

    var treeIsBuild = false;
    var file_system_content = {};

    function renderTreeView(changes) {
        const currentPath = [file_system_content.name];

        if (!treeIsBuild) {
            treeIsBuild = true;
            treeView.innerHTML = "";
            const rootTreeNode = createTreeNode(file_system_content, currentPath);
            treeView.appendChild(rootTreeNode);
            openPathInExplorerView(file_system_content);
            handleOpenClose(file_system_content, rootTreeNode);
            new PopupMenu(explorerView, ["contextmenu"], explorerCtxMenu);
        } else {
            applyChangesToTreeView(changes);
        }
    }

    function applyChangesToTreeView(changes) {
        changes.forEach(change => {
            switch (change.type) {
                case "added":
                    addNodeToTreeView(change.path, change.node);
                    break;
                case "removed":
                    removeNodeFromTreeView(change.path, change.node);
                    break;
                case "updated":
                    updateNodeInTreeView(change.path, change.node);
                    break;
            }
        });
    }

    function addNodeToTreeView(path, node) {
        let parentPath = getParentPath(path);
        let parent = getContentByPath(parentPath);
        if (parent && parent.sub) {
            parent.path = parentPath;
            const parentNode = getTreeNode(parent);
            const parentNodeSub = parentNode.classList.contains('sub-folder') ? parentNode : parentNode.querySelector("div[class='sub-folder']");
            if (parentNodeSub != null) {
                var pathArr = path.split("/");
                var newNode = createTreeNode(node, pathArr);
                var newNodeIsDir = newNode.dataset.isDirectory === "true";
                var newNodeName = pathArr[pathArr.length - 1];
                var index = 0;
                var found = false;
                parentNodeSub.childNodes.forEach(childNode => {
                    if (found || childNode.dataset.path === undefined)
                        return;
                    var childNodeIsDir = childNode.dataset.isDirectory === "true";
                    var childNodeName = childNode.dataset.path.substring(childNode.dataset.path.lastIndexOf("/") + 1);

                    var res = newNodeName.localeCompare(childNodeName);
                    if (res == -1 && (newNodeIsDir == childNodeIsDir)) {
                        found = true;
                        return;
                    }

                    if (!newNodeIsDir || childNodeIsDir)
                        index++;
                });

                index = index >= parentNodeSub.childNodes.length ? (newNodeIsDir ? parentNodeSub.childNodes.length : 0) : index
                parentNodeSub.insertBefore(newNode, parentNodeSub.childNodes[index]);

                if (!node.isDirectory)
                    openPathInExplorerView(node);
                else
                    openPathInExplorerView(getContentByPath(getParentPath(node.path)));
            }
        }
    }

    function removeNodeFromTreeView(path, node) {
        let parentPath = getParentPath(path);
        let parent = getContentByPath(parentPath);
        if (parent && parent.sub) {
            const childNode = getTreeNode(node);
            if (childNode === null) return;
            const parentNode = childNode.parentNode;
            if (parentNode != null && childNode != null) {
                parentNode.removeChild(childNode);
                openPathInExplorerView(parent);
            }
        }
    }

    function updateNodeInTreeView(path, node) {
        let parentPath = getParentPath(path);
        let parent = getContentByPath(parentPath);
        if (parent && parent.sub) {
            const childNode = getTreeNode(node);
            if (childNode === null) return;
            const parentNode = childNode.parentNode;
            if (parentNode != null && childNode != null) {
                parentNode.removeChild(childNode);
                parentNode.appendChild(createTreeNode(node, path));
                openPathInExplorerView(node);
            }
        }
    }

    function createTreeNode(content, currentPath) {
        let path = currentPath.join('/');
        path = path.length > 1 && path[1] == "/" ? path.substring(1) : path;
        const finalPath = path;
        const treeElement = dCre('div');
        treeElement.className = 'folder';
        treeElement.setAttribute("name", finalPath);
        treeElement.dataset.path = finalPath;
        content.path = finalPath;
        treeElement.dataset.isDirectory = content.isDirectory;

        const expContainer = dCre('div');
        expContainer.classList.add("svg-div");
        expContainer.setAttribute("name", "expContainer");
        expContainer.addEventListener("click", function (event) {
            content.isOpen = !content.isOpen;
            handleOpenClose(content, treeElement);
        });

        const markableContainer = dCre('div');
        markableContainer.dataset.path = content.path;
        markableContainer.classList.add("markable");
        markableContainer.addEventListener("click", function (event) {
            let actives = treeView.querySelectorAll("div[class='markable active']");
            actives.forEach(element => {
                element.classList.remove("active");
            });

            markableContainer.classList.add("active");
            openPathInExplorerView(getContentByPath(finalPath));
        });
        markableContainer.addEventListener("dblclick", function (event) {
            content.isOpen = !content.isOpen;
            handleOpenClose(content, treeElement);
            openPathInExplorerView(getContentByPath(finalPath));

            if (!content.isDirectory)
                editItem(content);
        });

        if (content.isDirectory) {
            markableContainer.addEventListener("drop", function (event) {
                dropHandler(event);
            });
            markableContainer.addEventListener("dragover", function (event) {
                dragOverHandler(event);
            });
            new PopupMenu(markableContainer, ["contextmenu"], [
                {
                    label: "<b>Open</b>",
                    onclick: function () {
                        openPathInExplorerView(content);
                    }
                },
                /* {
                    label: "Cut",
                    onclick: function () {
                        // TODO
                    }
                },
                {
                    label: "Copy",
                    onclick: function () {
                        // TODO
                    }
                }, */
                {
                    label: "Delete",
                    onclick: function () {
                        removeDir(content.path);
                    }
                },
                {
                    label: "Rename",
                    onclick: function () {
                        rename(content.path);
                    }
                }
            ]);
        } else {
            new PopupMenu(markableContainer, ["contextmenu"], [
                {
                    label: "<b>Edit</b>",
                    onclick: function () {
                        editItem(content);
                    }
                },
                {
                    label: "Download",
                    onclick: function () {
                        downloadItem(content);
                    }
                },
                /* {
                    label: "Cut",
                    onclick: function () {
                        // TODO
                    }
                },
                {
                    label: "Copy",
                    onclick: function () {
                        // TODO
                    }
                }, */
                {
                    label: "Delete",
                    onclick: function () {
                        removeFile(content.path);
                    }
                },
                {
                    label: "Rename",
                    onclick: function () {
                        rename(content.path);
                    }
                }
            ]);
        }
        const iconContainer = dCre('div');
        iconContainer.setAttribute("name", "iconContainer");
        iconContainer.classList.add("svg-div");

        const nameSpan = dCre('span');
        nameSpan.style.margin = "0 0 0 4px";
        nameSpan.textContent = content.name;

        markableContainer.appendChild(iconContainer);
        markableContainer.appendChild(nameSpan);

        treeElement.appendChild(expContainer);
        treeElement.appendChild(markableContainer);

        if (content.sub) {
            const subElContainer = dCre('div');
            subElContainer.className = 'sub-folder';
            subElContainer.setAttribute("name", "subElContainer");

            content.sub.forEach(subElement => {
                currentPath.push(subElement.name);
                subElContainer.appendChild(createTreeNode(subElement, currentPath));
                currentPath.pop();
            });
            treeElement.appendChild(subElContainer);
        }

        handleOpenClose(content, treeElement);

        return treeElement;
    }

    function handleOpenClose(element, treeElement) {
        const expContainer = treeElement.querySelector("div[name='expContainer']");
        const iconContainer = treeElement.querySelector("div[name='iconContainer']");
        const subElContainer = treeElement.querySelector("div[name='subElContainer']");

        if (expContainer === null || iconContainer === null || subElContainer === null)
            return;

        if (element.isDirectory) {
            if (element.isOpen) {
                expContainer.innerHTML = '<svg viewBox="0 0 12 12" width="12" height="12">' + arrow_down_svg_symbol + '</svg>';
                iconContainer.innerHTML = '<svg viewBox="0 0 16 16" width="16" height="16">' + folder_open_svg_symbol + '</svg>';
            } else {
                expContainer.innerHTML = '<svg viewBox="0 0 12 12" width="12" height="12">' + arrow_right_svg_symbol + '</svg>';
                iconContainer.innerHTML = '<svg viewBox="0 0 16 16" width="16" height="16">' + folder_closed_svg_symbol + '</svg>';
            }
        } else {
            expContainer.innerHTML = '<span style="width: 12px;display: inline-block;"></span>';
            iconContainer.innerHTML = '<svg viewBox="0 0 16 16" width="16" height="16">' + file_svg_symbol + '</svg>';
        }

        if (element.sub && element.sub.length > 0) {
            subElContainer.style.display = element.isOpen ? "block" : "none";
        }
    }

    function buildExplorerView(content) {
        if (content === null || content === undefined)
            return;

        if (!content.isDirectory) {
            // get parent and open this
            content = getContentByPath(getParentPath(content.path))

            if (content === null)
                return;
        }

        explorerView.dataset.path = content.path;
        explorerView.innerHTML = '';

        setPathTb(content);

        const table = dCre('table');
        table.classList.add("explorer-table");
        const headerRow = dCre('tr');

        const nameHeader = dCre('th');
        nameHeader.textContent = 'Name';
        nameHeader.style.width = "100%";
        headerRow.appendChild(nameHeader);

        const typeHeader = dCre('th');
        typeHeader.textContent = 'Type';
        headerRow.appendChild(typeHeader);

        const sizeHeader = dCre('th');
        sizeHeader.textContent = 'Size';
        headerRow.appendChild(sizeHeader);

        table.appendChild(headerRow);
        explorerView.appendChild(table);

        if (content.sub && content.sub.length > 0) {
            content.sub.forEach(item => {
                const row = dCre('tr');

                const nameCell = dCre('td');
                const markableContainer = dCre('div');
                markableContainer.dataset.path = item.path;
                markableContainer.classList.add("markable");
                markableContainer.addEventListener("click", function (event) {
                    let actives = explorerView.querySelectorAll("div[class='markable active']");
                    actives.forEach(element => {
                        element.classList.remove("active");
                    });

                    markableContainer.classList.add("active");
                });
                markableContainer.addEventListener("contextmenu", function (event) {
                    let actives = explorerView.querySelectorAll("div[class='markable active']");
                    actives.forEach(element => {
                        element.classList.remove("active");
                    });

                    markableContainer.classList.add("active");
                });
                markableContainer.addEventListener("dblclick", function (event) {
                    if (item.isDirectory) {
                        openPathInExplorerView(item);
                    } else {
                        editItem(item);
                    }
                });
                if (item.isDirectory) {
                    markableContainer.addEventListener("drop", function (event) {
                        dropHandler(event);
                    });
                    markableContainer.addEventListener("dragover", function (event) {
                        dragOverHandler(event);
                    });
                    new PopupMenu(markableContainer, ["contextmenu"], [
                        {
                            label: "<b>Open</b>",
                            onclick: function () {
                                openPathInExplorerView(item);
                            }
                        },
                        /* {
                            label: "Cut",
                            onclick: function () {
                                // TODO
                            }
                        },
                        {
                            label: "Copy",
                            onclick: function () {
                                // TODO
                            }
                        }, */
                        {
                            label: "Delete",
                            onclick: function () {
                                removeDir(item.path);
                            }
                        },
                        {
                            label: "Rename",
                            onclick: function () {
                                rename(item.path);
                            }
                        }
                    ]);
                } else {
                    new PopupMenu(markableContainer, ["contextmenu"], [
                        {
                            label: "<b>Edit</b>",
                            onclick: function () {
                                editItem(item);
                            }
                        },
                        {
                            label: "Download",
                            onclick: function () {
                                downloadItem(item);
                            }
                        },
                        /* {
                            label: "Cut",
                            onclick: function () {
                                // TODO
                            }
                        },
                        {
                            label: "Copy",
                            onclick: function () {
                                // TODO
                            }
                        }, */
                        {
                            label: "Delete",
                            onclick: function () {
                                removeFile(item.path);
                            }
                        },
                        {
                            label: "Rename",
                            onclick: function () {
                                rename(item.path);
                            }
                        }
                    ]);
                }
                const iconContainer = dCre('div');
                iconContainer.setAttribute("name", "iconContainer");
                iconContainer.classList.add("svg-div");
                if (item.isDirectory) {
                    iconContainer.innerHTML = '<svg viewBox="0 0 16 16" width="16" height="16">' + folder_closed_svg_symbol + '</svg>';
                } else {
                    iconContainer.innerHTML = '<svg viewBox="0 0 16 16" width="16" height="16">' + file_svg_symbol + '</svg>';
                }

                const nameSpan = dCre('span');
                nameSpan.style.margin = "0 12px 0 4px";
                nameSpan.textContent = item.name;

                markableContainer.appendChild(iconContainer);
                markableContainer.appendChild(nameSpan);
                nameCell.appendChild(markableContainer);
                row.appendChild(nameCell);


                const typeCell = dCre('td');
                if (!item.isDirectory) {
                    let ext = getFileExtension(item.name).toUpperCase();
                    typeCell.textContent = (ext.length > 0 ? (ext + '-File') : 'File');
                } else {
                    typeCell.textContent = 'Folder';
                }

                row.appendChild(typeCell);

                const sizeCell = dCre('td');
                sizeCell.textContent = item.isDirectory ? '-' : `${item.size} bytes`;
                row.appendChild(sizeCell);

                table.appendChild(row);
            });
        } else {
            const emptyMessage = dCre('p');
            emptyMessage.textContent = 'This folder is empty.';
            explorerView.appendChild(emptyMessage);
        }
    }

    function rename(path) {
        var newName = prompt("Enter a new name", path);
        if (newName != null) {
            post("mv",
                function (ev) {
                    if (ev.xhrOK)
                        showNewToast(ev.response, "green");
                    else
                        showNewToast(ev.response, "red");
                },
                "path=" + encodeURIComponent(path) + "&to=" + encodeURIComponent(newName)
            );
        }
    }

    function mkFile() {
        var path = explorerView.dataset.path;
        var filename = prompt("Enter Filename");
        if (filename != null) {
            post("mk",
                function (ev) {
                    if (ev.xhrOK)
                        showNewToast(ev.response, "green");
                    else
                        showNewToast(ev.response, "red");
                },
                "path=" + encodeURIComponent(path + "/" + filename)
            );
        }
    }

    function mkDir() {
        var path = explorerView.dataset.path;
        var name = prompt("Enter a directory name");
        if (name != null) {
            post("mkdir",
                function (ev) {
                    if (ev.xhrOK)
                        showNewToast(ev.response, "green");
                    else
                        showNewToast(ev.response, "red");
                },
                "path=" + encodeURIComponent(path + "/" + name)
            );
        }
    }

    function removeDir(path) {
        if (confirm("Delete '" + path + "' permanently?"))
            post("rmdir",
                function (ev) {
                    if (ev.xhrOK)
                        showNewToast(ev.response, "green");
                    else
                        showNewToast(ev.response, "red");
                },
                "path=" + encodeURIComponent(path)
            );
    }

    function removeFile(path) {
        if (confirm("Delete '" + path + "' permanently?"))
            post("rm",
                function (ev) {
                    if (ev.xhrOK)
                        showNewToast(ev.response, "green");
                    else
                        showNewToast(ev.response, "red");
                },
                "path=" + encodeURIComponent(path)
            );
    }

    function downloadItem(item) {
        const a = document.createElement('a');
        a.href = getContentPath(item);
        a.download = item.name;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
    }

    async function editItem(item) {
        loadFile(getContentPath(item), function (content) {
            fileContentTextarea.value = content;
            fileEditorFilename.innerText = getContentPath(item);
            showWindow('file-editor-window');
        });
    }

    function openPathInExplorerView(content) {
        if (content === null || content === undefined)
            return;

        // open and mark path in tree-view
        let actives = treeView.querySelectorAll("div[class='markable active']");
        actives.forEach(element => {
            element.classList.remove("active");
        });

        // show content in explorer-view
        buildExplorerView(content, content.path);
    }

    function setPathTb(content) {
        var path = getContentPath(content);

        // write path to path_tb
        if (path_tb.dataset.path)
            back_stack.push(path_tb.dataset.path);
        else
            back_stack.push(file_system_content.path);

        path_tb.dataset.path = path;
        path_tb.value = path === "" ? "/" : path;
    }

    function goBack() {
        let lastPath = back_stack.pop();
        if (lastPath != undefined) {
            fwd_stack.push(path_tb.dataset.path);
            openPathInExplorerView(getContentByPath(lastPath));
            back_stack.pop(); // remove this navigation
        }
    }

    function goFwd() {
        let lastPath = fwd_stack.pop();
        if (lastPath != undefined) {
            back_stack.push(path_tb.dataset.path);
            openPathInExplorerView(getContentByPath(lastPath));
            back_stack.pop(); // remove this navigation
        }
    }

    function dropHandler(ev) {
        ev.currentTarget.classList.remove('highlight');

        ev.preventDefault();
        ev.stopPropagation();

        if (ev.dataTransfer) {
            if (ev.dataTransfer.items) {
                [...ev.dataTransfer.items].forEach((item, i) => {
                    if (item.kind === "file") {
                        const file = item.getAsFile();
                        var targetPath = ev.currentTarget.dataset.path;
                        var path = targetPath + (targetPath.endsWith("/") ? "" : "/") + file.name;

                        var test = getContentByPath(path);

                        if (test && !confirm("File '" + path + "' already exists. Overwrite?"))
                            return;

                        uploadFile(file, path);
                    }
                });
            }
        }
    }

    function dragOverHandler(ev) {
        ev.currentTarget.classList.add('highlight');

        const win = findAncestor(ev.currentTarget, "window");
        if (win)
            bringtToFront(win);

        ev.currentTarget.addEventListener('dragleave', function (event) {
            event.currentTarget.classList.remove('highlight');
        }, {
            once: true
        });

        // Prevent default behavior (Prevent file from being opened)
        ev.preventDefault();
    }

    function findAncestor(el, cls) {
        while ((el = el.parentElement) && !el.classList.contains(cls));
        return el;
    }

    // #region Helpers
    function getTreeNode(item) {
        const rootContent = treeView.childNodes[0].querySelector("div[class='sub-folder']");
        const contentPath = getContentPath(item);
        var found = false;
        var treeNodes = [];

        function iterate(c) {
            if (c === null)
                return false;

            c.childNodes.forEach(subElement => {
                if (found)
                    return true;

                let currentPath = subElement.dataset.path;
                const nextContent = subElement.querySelector("div[class='sub-folder']");

                if (currentPath === contentPath) {
                    treeNodes.push(subElement);
                    found = true;
                    return true;
                }

                iterate(nextContent);
            });
        }

        if (treeView.childNodes[0].dataset.path === contentPath)
            return rootContent;

        iterate(rootContent);

        return treeNodes.length > 0 ? treeNodes[0] : null;
    }

    function getContentPath(content) {
        if (content.path !== undefined)
            return content.path;
        return "/";
    }

    function getContentByPath(path, content = file_system_content) {
        const parts = path.split('/').filter(part => part !== "");
        let current = content;

        for (const part of parts) {
            if (!current.sub || !current.isDirectory)
                return null;

            const next = current.sub.find(sub => sub.name === part);
            if (!next)
                return null;

            current = next;
        }

        return current;
    }

    function getFileExtension(filename) {
        return filename.split('.').pop();
    }

    function getParentPath(filePath) {
        const lastSlashIndex = filePath.lastIndexOf('/');
        if (lastSlashIndex === -1)
            return '/';

        let parentPath = filePath.substring(0, lastSlashIndex);
        if (parentPath === "")
            parentPath = "/";

        return parentPath;
    }
    // #endregion Helpers
</script>

<!-- Popup Menu -->
<script>
    // light mode
    const color = "#3b3b3b";
    const color_highlight = "#000";
    const bg_color = "#fff";
    const bg_color_highlight = "#e8e8e8";
    const border_color = "#cecece";
    // dark mode
    const color_dark = "#ccc";
    const color_highlight_dark = "#fff";
    const bg_color_dark = "#1f1f1f";
    const bg_color_highlight_dark = "#04395e";
    const border_color_dark = "#454545";

    class PopupMenu {
        constructor(sender, eventTypes, menuItems) {
            this.sender = sender;
            this.eventTypes = eventTypes;
            this.menuItems = menuItems;

            for (var i = 0; i < this.eventTypes.length; i++) {
                const eventType = eventTypes[i];
                const popupMenu = this;
                this.sender.addEventListener(eventType, function (event) {
                    event.preventDefault();
                    event.stopPropagation();

                    PopupMenu.removeMenu();

                    const _x = event.clientX;
                    const _y = event.clientY;

                    const cm = PopupMenu.createMenu(_x, _y, popupMenu.sender, popupMenu.menuItems, isDarkMode());
                    document.body.appendChild(cm);

                    PopupMenu.checkPosWithinScreen(cm);
                });
            }
        }

        addItems(menuItems) {
            if (Array.isArray(menuItems))
                this.menuItems.push(...menuItems);
            else
                this.menuItems.push(menuItems);
        }

        // Outer DIV
        static createMenu(x, y, sender, items, darkmode) {
            const cm = document.createElement("div");
            cm.setAttribute("name", "PopupMenu");

            document.addEventListener("click", PopupMenu.removeMenu);

            cm.setAttribute("style", 'display: block; min-width: 150px; position: absolute; box-sizing: border-box; outline: 0px; z-index: 2002;box-shadow: 0 0 7px rgba(50,50,50,.4);border: 1px solid; border-radius: 5px; font-size: 12px;cursor: default;padding: 4px; white-space: nowrap; overflow-x: visible; max-height: 561px; overflow-y: visible;text-align: left;')

            cm.style.left = x + "px";
            cm.style.top = y + "px";
            cm.style.backgroundColor = darkmode ? bg_color_dark : bg_color;
            cm.style.borderColor = darkmode ? border_color_dark : border_color;
            cm.dataset.sender_id = sender.id;

            const menu_div = PopupMenu.createMenuDiv(items, darkmode, sender);

            cm.appendChild(menu_div);

            return cm;
        }

        // Item holder DIV
        static createMenuDiv(items, darkmode, sender) {
            const menu_div = document.createElement("div");
            menu_div.role = "menu";
            menu_div.style.outline = 0;

            for (var i = 0; i < items.length; i++) {
                var item = items[i];

                const menu_item = PopupMenu.createMenuItemDiv(item, darkmode);

                // Sub-Items
                if (item.items && item.items.length > 0) {
                    menu_item.style.background = 'transparent no-repeat right';
                    var svg_str = "<svg xmlns='http://www.w3.org/2000/svg' width='50px' height='50px' viewBox='0 0 256 256'><g fill='" + (darkmode ? color_dark : color) + "'><g transform='scale(5.12,5.12)'><path d='M16,5v42l22,-21z'></path></g></g></svg>"
                    var svg_url = 'url("data:image/svg+xml,' + encodeURIComponent(svg_str) + '")';
                    menu_item.style.backgroundImage = svg_url;
                    menu_item.style.backgroundPosition = 'right 6px top 9px';
                    menu_item.style.backgroundSize = '12px';

                    menu_item.dataset.subMenuShown = "false";

                    const _subItems = item.items;

                    menu_item.addEventListener("mouseover", function (ev) {
                        const cm = PopupMenu.createMenu(menu_item.offsetWidth, menu_item.offsetTop, sender, _subItems, darkmode);
                        if (menu_item.dataset.subMenuShown === "false") {
                            menu_item.dataset.subMenuShown = "true";
                            menu_item.appendChild(cm);
                            PopupMenu.checkPosWithinScreen(cm);
                        }
                    });

                    menu_item.addEventListener("mouseleave", function (ev) {
                        if (menu_item.dataset.subMenuShown === "true") {
                            for (let i = menu_item.childNodes.length - 1; i >= 0; i--) {
                                if (menu_item.childNodes[i].nodeName === 'DIV') {
                                    menu_item.removeChild(menu_item.childNodes[i]);
                                    menu_item.dataset.subMenuShown = "false";
                                    return;
                                }
                            }
                        }
                    });
                }

                menu_div.appendChild(menu_item);
            }

            return menu_div;
        }

        // Menu item DIV
        static createMenuItemDiv(item, darkmode) {
            // Item outer DIV
            const menu_item = document.createElement("div");
            menu_item.role = "menuitem";

            menu_item.style.display = "block";
            menu_item.style.cursor = "pointer";
            menu_item.style.borderRadius = "3px";
            menu_item.style.backgroundColor = (darkmode ? bg_color_dark : bg_color);
            menu_item.style.color = (item.color ? item.color : (darkmode ? color_dark : color));
            menu_item.style.padding = "6px";

            switch (item.type) {
                case "title":
                    menu_item.style.userSelect = "none";
                    menu_item.style.backgroundColor = (darkmode ? border_color_dark : border_color);
                    menu_item.style.marginBottom = "6px";
                    menu_item.style.lineHeight = "0.9";
                    break;
                default:
                    menu_item.setAttribute("onmouseover", 'this.style.backgroundColor = "' + (darkmode ? bg_color_highlight_dark : bg_color_highlight) + '"; this.style.color = "' + (item.color ? item.color : (darkmode ? color_highlight_dark : color_highlight)) + '";');
                    menu_item.setAttribute("onmouseout", 'this.style.backgroundColor = "' + (item.backgroundColor ? item.backgroundColor : (darkmode ? bg_color_dark : bg_color)) + '"; this.style.color = "' + (item.color ? item.color : (darkmode ? color_dark : color)) + '";');

            }

            if (item.onclick) {
                menu_item.addEventListener("click", item.onclick);
            }

            // Icon
            if (item.icon && item.icon.type && item.icon.src) {
                switch (item.icon.type) {
                    case "url":
                        const icon = document.createElement("span");
                        icon.style.display = "inline-block";
                        icon.style.verticalAlign = "middle";
                        icon.style.width = "18px";
                        icon.style.height = "18px";

                        if (item.icon.src_dark && darkmode) {
                            icon.style.background = "url('" + item.icon.src_dark + "')";
                        } else {
                            icon.style.background = "url('" + item.icon.src + "')";
                        }
                        icon.style.backgroundRepeat = "no-repeat";
                        icon.style.backgroundSize = "18px";

                        // user custom styles
                        if (item.icon.style)
                            icon.style.cssText += item.icon.style;

                        menu_item.appendChild(icon);
                        break;
                    case "svg_path":
                        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                        svg.style.margin = "5px 0px 5px 8px";
                        svg.setAttribute('width', '18');
                        svg.setAttribute('height', '18');
                        svg.innerHTML = '<path d="' + item.icon.src + '" stroke="' + (item.color ? item.color : (darkmode ? color_dark : color)) + '"/>';
                        menu_item.appendChild(svg);
                        break;
                }
            }

            // Label
            const label = document.createElement("span");

            label.style.margin = "0 8px";
            label.style.verticalAlign = "middle";

            label.innerHTML = item.label;
            menu_item.appendChild(label);

            return menu_item;
        }

        // Helpers
        static checkPosWithinScreen(el) {
            var parentOffsetLeft = el.offsetParent.dataset.left ? parseInt(el.offsetParent.dataset.left) : el.offsetParent.offsetLeft;
            var parentOffsetTop = el.offsetParent.dataset.top ? parseInt(el.offsetParent.dataset.top) : el.offsetParent.offsetTop;

            if (parentOffsetLeft + el.offsetLeft + el.offsetWidth > window.innerWidth) {
                var offsetLeft = window.innerWidth - parentOffsetLeft - el.offsetWidth - 3;
                el.style.left = offsetLeft + "px";
                el.dataset.left = offsetLeft + parentOffsetLeft;
            } else {
                el.dataset.left = el.offsetLeft + parentOffsetLeft;
            }

            if (parentOffsetTop + el.offsetTop + el.offsetHeight > window.innerHeight) {
                var offsetTop = window.innerHeight - parentOffsetTop - el.offsetHeight - 3;
                el.style.top = offsetTop + "px";
                el.dataset.top = offsetTop + parentOffsetTop;
            } else {
                el.dataset.top = el.offsetTop + parentOffsetTop;
            }

            return true;
        }

        static removeMenu() {
            try {
                var cms = document.getElementsByName("PopupMenu");
                cms.forEach(el => {
                    document.body.removeChild(el);
                });

                document.removeEventListener("click", removeMenu);
            } catch (error) {
            }
        }
    }

    function isDarkMode() {
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            // Dark Mode ist aktiviert
            return true;
        } else {
            // Dark Mode ist nicht aktiviert
            return false;
        }
    }
</script>

</html>